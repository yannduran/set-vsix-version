# yaml-language-server: $schema=https://json.schemastore.org/github-action.json
name: "Set VSIX Version Number"
description: "Sets the version number in the VSIX manifest and generated code-behind file (if one exists)"
branding:
  icon: hash
  color: purple

inputs:
  version-number:
    description: "Version number to set"
    required: false
    type: string
    default: ""

  development-version:
    description: "Development version number"
    required: false
    type: string
    default: ""

  production-version:
    description: "Production version number"
    required: false
    type: string
    default: ""

  production-tag:
    description: "A regex expression that defines a valid production tag"
    required: false
    type: string
    default: "**"

  git-ref:
    description: "The repo's git ref"
    required: false
    type: string
    default: ""

  vsix-manifest-file:
    description: "Path to VSIX manifest file (source.extension.vsixmanifest)"
    required: true
    type: string
    default: src\vsix\source.extension.vsixmanifest

  vsix-code-file:
    description: "Path to generated code file (source.extension.vs)"
    required: false
    type: string
    default: src\vsix\source.extension.cs

runs:
  using: "composite"

  steps:
    - name: Set version in VSIX manifest and file (if it exists)
      shell: pwsh

      run: |
        function WriteInfo {
          param([string]$message)
          Write-Host ${message} -ForegroundColor Magenta
        }

        function WriteError {
          param([string]$message)
          Write-Host ${message} -ForegroundColor Yellow
        }

        function WriteException {
          param([string]$message)
          Write-Host ${message} -ForegroundColor Red
        }

        # try {
          $versionNumber = ${{ inputs.version-number }}
          $development = ${{ inputs.development-version }}
          $production = ${{ inputs.production-version }}
          $productionTag = "${{ inputs.production-tag }}"
          $gitRef = ${{ inputs.git-ref }}
          $manifestFile = ${{ inputs.manifest-file }}
          $codeFile = ${{ inputs.code-file }}

          $tags = 'refs/tags/'
          $heads = 'refs/heads/'
          $valid = $false

          if ($versionNumber -ne '')
          {
            # use specified version
            $valid = $true
          }
          else
          {
            if (($development -eq '') -or ($production -eq '') -or ($gitRef -eq '')) 
            {
              $message = 'No version number was specified, so development-version, production-version and git-ref are all required'

              throw new-object System.ArgumentException $message
            } 

            if ($gitRef.StartsWith($heads))
            {
              $branch = $gitRef.Replace($heads,'')

              WriteInfo "Ref: $gitRef"
              WriteInfo "Branch: $branch"
              $versionNumber = $development
              $valid = $true
            }

            if ($gitRef.StartsWith($tags))
            {
              $tag = $gitRef.Replace($tags,'')

              WriteInfo "Ref: $gitRef"
              WriteInfo "Regex: $productionTag"

              if ($tag -match $productionTag)
              {
                WriteInfo "'$tag' IS a production tag"
                $versionNumber = $production
              }
              else
              {
                WriteInfo "'$tag' IS NOT a production tag"
                $versionNumber = $development
              }
              $valid = $true
            }  
            
            if ($valid -ne $true)
            {
              throw new-object System.InvalidOperationException "'$gitref' is not currently supported"  
            }
          }

          $manifestRegex = 'Version="([0-9\\.]+)" Language='
          $codeRegex = 'Version = "([0-9\\.]+)"'
          
          function GetManifestVersion{
            param([string]$path)
            $regex = New-Object System.Text.RegularExpressions.Regex $manifestRegex
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          function GetCodeVersion{
            param([string]$path)
            $regex = New-Object System.Text.RegularExpressions.Regex $codeRegex
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          if ($valid -eq $true)
          {
            WriteInfo "Version to set: $versionNumber"

            $manifestVersion = GetManifestVersion($manifestFile)
            WriteInfo("Before (manifest): $manifestVersion")

            # set version number in manifest file
            $replacement = 'Version="' + $versionNumber + '" Language='
            $content = [string]::join([environment]::newline, (get-content $manifestFile))
            $regex = New-Object System.Text.RegularExpressions.Regex $manifestRegex
            $regex.Replace($content, $replacement) | Out-File $manifestFile

            $manifestVersion = GetManifestVersion($manifestFile)
            WriteInfo("After (manifest): $manifestVersion")

            # Get-Content $manifestFile

            if ([System.IO.File]::Exists($codeFile))
            {
              $codeVersion = GetCodeVersion($codeFile)
              WriteInfo("Before (code): $codeVersion")  

              # set version number in code file (if it exists)
              $replacement = 'Version = "' + $versionNumber +'"'
              $content = [string]::join([environment]::newline, (get-content $codeFile))
              $regex = New-Object System.Text.RegularExpressions.Regex $codeRegex
              $regex.Replace($content, $replacement) | Out-File $codeFile

              $codeVersion = GetCodeVersion($codeFile)
              WriteInfo("After (code): $codeVersion")  
              }
          }
        # }
        # catch [System.ArgumentException]
        # {
        #   WriteError $_
        # }
        # catch [System.InvalidOperationException]
        # {
        #   WriteError $_
        # }
        # catch
        # {
        #   WriteException "An unexpected error occurred: $_"
        #   WriteException $_.ScriptStackTrace
        # }

    - name: Show results
      shell: pwsh

      run: |
        function WriteInfo {
          param([string]$message)
          Write-Host $message -ForegroundColor Magenta
        }

        function WriteError {
          param([string]$message)
          Write-Host $message -ForegroundColor Yellow
        }

        function WriteException {
          param([string]$message)
          Write-Host $message -ForegroundColor Red
        }

        try
        {
          $manifestFile = ${{ inputs.manifest-file }}
          $codeFile = ${{ inputs.code-file }}

          function GetManifestVersion{
            param([string]$path)
            $regex = New-Object System.Text.RegularExpressions.Regex 'Version="([0-9\\.]+)" Language='
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          function GetCodeVersion{
            param([string]$path)
            $regex = New-Object System.Text.RegularExpressions.Regex 'Version = "([0-9\\.]+)"'
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          $manifestVersion = GetManifestVersion($manifestFile)
          WriteInfo("After (manifest): $manifestVersion")

          if ([System.IO.File]::Exists($codeFile))
          {
            $codeVersion = GetCodeVersion($codeFile)
            WriteInfo("After (code): $codeVersion")  
            }
        }
        catch
        {
          WriteException "An unexpected error occurred: $_"
          WriteException $_.ScriptStackTrace
        }
