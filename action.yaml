# yaml-language-server: $schema=https://json.schemastore.org/github-action.json
name: "Set VSIX Version Number"
description: "Sets the version number in the VSIX manifest and generated code-behind file (if one exists)"
branding:
  icon: hash
  color: purple

inputs:
  version-number:
    description: "Version number to set"
    required: false
    type: string
    default: ""

  development-version:
    description: "Development version number"
    required: false
    type: string
    default: ""

  production-version:
    description: "Production version number"
    required: false
    type: string
    default: ""

  production-tag:
    description: "A regex expression that defines a valid production tag"
    required: false
    type: string
    default: "**"

  git-ref:
    description: "The repo's git ref"
    required: false
    type: string
    default: ""

  vsix-manifest-file:
    description: "Path to VSIX manifest file (source.extension.vsixmanifest)"
    required: true
    type: string
    default: src/vsix/source.extension.vsixmanifest

  vsix-code-file:
    description: "Path to generated code file (source.extension.vs)"
    required: false
    type: string
    default: src/vsix/source.extension.cs

runs:
  using: "composite"

  steps:
    - name: Set version in VSIX manifest and file (if it exists)
      shell: pwsh

      run: |
        function LogInfo {
          [CmdletBinding()]
          param(
            [Parameter(Mandatory=$true, Position=0)]
            [string]$message
          )
          
          Write-Host "INFO: ${message}" -ForegroundColor Magenta
        }

        function LogError {
          [CmdletBinding()]
          param(
            [Parameter(Mandatory=$true, Position=0)]
            [string]$message
          )
          
          Write-Host "ERROR: ${message}" -ForegroundColor Yellow
        }

        function LogException {
          [CmdletBinding()]
          param(
            [Parameter(Mandatory=$true, Position=0)]
            [string]$message
          )
          
          Write-Host "EXCEPTION: ${message}" -ForegroundColor Red
        }

        # try {
          $versionNumber = ${{ inputs.version-number }}
          $development = ${{ inputs.development-version }}
          $production = ${{ inputs.production-version }}
          $productionTag = "${{ inputs.production-tag }}"
          $gitRef = "${{ inputs.git-ref }}"
          $manifestFile = ${{ inputs.manifest-file }}
          $codeFile = ${{ inputs.code-file }}

          $tags = 'refs/tags/'
          $heads = 'refs/heads/'
          $valid = $false

          LogInfo $(Get-Date -Format 'yyyy-MMM-dd HH:mm:ss')

          if ($versionNumber -ne '')
          {
            # use specified version
            $valid = $true
          }
          else
          {
            if (($development -eq '') -or ($production -eq '') -or ($gitRef -eq '')) 
            {
              $message = "Input 'version-number' was not specified
                Therefore 'development-version', 'production-version' and 'git-ref'
                inputs are all required"

              throw new-object System.ArgumentException $message
            } 

            if ($gitRef.StartsWith($heads))
            {
              $branch = $gitRef.Replace($heads,'')

              LogInfo "Ref: $gitRef"
              LogInfo "Branch: $branch"
              $versionNumber = $development
              $valid = $true
            }

            if ($gitRef.StartsWith($tags))
            {
              $tag = $gitRef.Replace($tags,'')

              LogInfo "Ref: $gitRef"
              LogInfo "Regex: $productionTag"

              if ($tag -match $productionTag)
              {
                LogInfo "'$tag' IS a production tag"
                $versionNumber = $production
              }
              else
              {
                LogInfo "'$tag' IS NOT a production tag"
                $versionNumber = $development
              }
              $valid = $true
            }  
            
            if ($valid -ne $true)
            {
              throw new-object System.InvalidOperationException "'$gitref' is not currently supported"  
            }
          }

          $manifestRegex = 'Version="([0-9\\.]+)" Language='
          $codeRegex = 'Version = "([0-9\\.]+)"'
          
          function GetManifestVersion{
            [CmdletBinding()]
            param(
              [Parameter(Mandatory=$true, Position=0)]
              [string]$path
            )
            
            LogInfo("Path: $path")
            $regex = New-Object System.Text.RegularExpressions.Regex $manifestRegex
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          function GetCodeVersion{
            [CmdletBinding()]
            param(
              [Parameter(Mandatory=$true, Position=0)]
              [string]$path
            )
            
            LogInfo("Path: $path")
            $regex = New-Object System.Text.RegularExpressions.Regex $codeRegex
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          if ($valid -eq $true)
          {
            LogInfo "Version to set: $versionNumber"

            LogInfo("Manifest file path: $manifestFile")
            $manifestVersion = GetManifestVersion($manifestFile)
            LogInfo("Before (manifest): $manifestVersion")

            # set version number in manifest file
            $replacement = 'Version="' + $versionNumber + '" Language='
            $content = [string]::join([environment]::newline, (get-content $manifestFile))
            $regex = New-Object System.Text.RegularExpressions.Regex $manifestRegex
            $regex.Replace($content, $replacement) | Out-File $manifestFile

            $manifestVersion = GetManifestVersion($manifestFile)
            LogInfo("After (manifest): $manifestVersion")

            if ([System.IO.File]::Exists($codeFile))
            {
              LogInfo("Code file path: $codeFile")
              $codeVersion = GetCodeVersion($codeFile)
              LogInfo("Before (code): $codeVersion")  

              # set version number in code file (if it exists)
              $replacement = 'Version = "' + $versionNumber +'"'
              $content = [string]::join([environment]::newline, (get-content $codeFile))
              $regex = New-Object System.Text.RegularExpressions.Regex $codeRegex
              $regex.Replace($content, $replacement) | Out-File $codeFile

              $codeVersion = GetCodeVersion($codeFile)
              LogInfo("After (code): $codeVersion")  
            }
          }
        # }
        # catch [System.ArgumentException]
        # {
        #   LogError $_
        # }
        # catch [System.InvalidOperationException]
        # {
        #   LogError $_
        # }
        # catch
        # {
        #   LogException "An unexpected error occurred: $_"
        #   LogException $_.ScriptStackTrace
        # }

    - name: Show results
      shell: pwsh

      run: |
        function LogInfo {
          [CmdletBinding()]
          param(
            [Parameter(Mandatory=$true, Position=0)]
            [string]$message
          )
          
          Write-Host "INFO: ${message}" -ForegroundColor Magenta
        }

        function LogError {
          [CmdletBinding()]
          param(
            [Parameter(Mandatory=$true, Position=0)]
            [string]$message
          )
          
          Write-Host "ERROR: ${message}" -ForegroundColor Yellow
        }

        function LogException {
          [CmdletBinding()]
          param(
            [Parameter(Mandatory=$true, Position=0)]
            [string]$message
          )
          
          Write-Host "EXCEPTION: ${message}" -ForegroundColor Red
        }

        try
        {
          $manifestFile = ${{ inputs.manifest-file }}
          $codeFile = ${{ inputs.code-file }}

          function GetManifestVersion{
            [CmdletBinding()]
            param(
              [Parameter(Mandatory=$true, Position=0)]
              [string]$path
            )

            LogInfo("Path: $path")
            $regex = New-Object System.Text.RegularExpressions.Regex 'Version="([0-9\\.]+)" Language='
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          function GetCodeVersion{
            [CmdletBinding()]
            param(
              [Parameter(Mandatory=$true, Position=0)]
              [string]$path
            )

            LogInfo("Path: $path")
            $regex = New-Object System.Text.RegularExpressions.Regex 'Version = "([0-9\\.]+)"'
            $value = select-string -Path $path -Pattern $regex -AllMatches `
              | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

            return $value
          }

          LogInfo("Manifest file path: $manifestFile")
          $manifestVersion = GetManifestVersion($manifestFile)
          LogInfo("After (manifest): $manifestVersion")

          if ([System.IO.File]::Exists($codeFile))
          {
            LogInfo("Code file path: $codeFile")
            $codeVersion = GetCodeVersion($codeFile)
            LogInfo("After (code): $codeVersion")  
          }

          LogInfo "Ended: $(Get-Date -Format u)"       
        }
        catch
        {
          LogException "An unexpected error occurred: $_"
          LogException $_.ScriptStackTrace
        }
