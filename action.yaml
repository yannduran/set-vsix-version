# yaml-language-server: $schema=https://json.schemastore.org/github-action.json
name: "Set VSIX Version Number"
description: "Sets the version number in the VSIX manifest and generated code-behind file (if one exists)"
author: "Yann Duran <set-vsix-version@yannduran.com>"
branding:
  icon: hash
  color: purple

inputs:
  version-number:
    description: "Version number to set"
    required: false
    default: ""

  development-version:
    description: "Development version number"
    required: false
    default: ""

  production-version:
    description: "Production version number"
    required: false
    default: ""

  production-regex:
    description: "A regex expression that defines a valid production tag"
    required: false
    default: ""

  github-ref:
    description: "The repo's git ref"
    required: false
    default: ""

  manifest-file-path:
    description: "Path to VSIX manifest file (source.extension.vsixmanifest)"
    required: true
    default: src/vsix/source.extension.vsixmanifest

  code-file-path:
    description: "Path to generated code file (source.extension.vs)"
    required: false
    default: src/vsix/source.extension.cs

outputs:
  version-number:
    description: "The version that was set in the VSIX manifest/code file(s)"
    value: ${{ steps.set-version.outputs.version-number }}

runs:
  using: "composite"

  steps:
    - name: Set version in VSIX manifest and file (if it exists)
      id: set-version
      shell: pwsh

      run: |
        # Import-Module ./.github/workflows/Functions.psm1

        try {
          #region functions
            function LogInfo {
              [CmdletBinding()]
              param(
                [Parameter(Mandatory=$true, Position=0)]
                [string]$message
                )
              
              Write-Host "INFO: ${message}" -ForegroundColor Magenta
            }

            function LogError {
              [CmdletBinding()]
              param(
                [Parameter(Mandatory=$true, Position=0)]
                [string]
                $message
                )
              
              Write-Host "ERROR: ${message}" -ForegroundColor Yellow
            }

            function LogException {
              [CmdletBinding()]
              param(
                [Parameter(Mandatory=$true, Position=0)]
                [string]$message
                )
              
              Write-Host "EXCEPTION: ${message}" -ForegroundColor Red
            }

            function LogException {
              [CmdletBinding()]
              param(
                [Parameter(Mandatory=$true, Position=0)]
                [string]$message
                )
              
              Write-Host "EXCEPTION: ${message}" -ForegroundColor Red
            }

            function LogDate {
              [CmdletBinding()]
              param(
                [Parameter(Mandatory=$true, Position=0)]
                [string]$prefix
                )
              
              Write-Host "INFO: ${prefix} $(Get-Date -Format $dateFormat)" -ForegroundColor Magenta
            }

            function GetTextBetween {
              # https://powershellone.wordpress.com/2021/02/24/using-powershell-and-regex-to-extract-text-between-delimiters/

              [CmdletBinding()]
              param( 
                [Parameter(Mandatory, ValueFromPipeline = $true, Position = 0)]   
                [string]$Text,
                [Parameter(Position = 1)] 
                [char]$delimeter = '"'
              )
              $pattern = "(?<=\$delimeter).+?(?=\$delimeter)"

              return [regex]::Matches($Text, $pattern).Value
            }

            function GetManifestVersion {
              param([string]$path)

              $value = select-string -Path $path -Pattern $manifestRegex -AllMatches `
                | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

              if ($value -eq '') {
                return ''
              } 

              return $(GetTextBetween($value.Replace(' Language=','')))
            }

            function GetCodeVersion {
              param([string]$path)

              $value = select-string -Path $path -Pattern $codeRegex -AllMatches `
                | ForEach-Object { $_.Matches } | ForEach-Object { $_.Value }

              if ($value -eq '') {
                return ''
              }
              
              return $(GetTextBetween($value))
            }

            function ShowResults {
              param(
              [string] $manifestVersionBefore = '',
              [string] $manifestVersionAfter = '', 
              [bool]   $codeFilePathExists = $false,
              [string] $codeVersionBefore = '',
              [string] $codeVersionAfter = ''
              )

              LogInfo("-------------")
              LogInfo("Manifest file")
              LogInfo("-------------")
              LogInfo(" - before: $manifestVersionBefore")
              LogInfo(" - after : $manifestVersionAfter")

              if ($codeFilePathExists -eq $true) {
                LogInfo("---------")
                LogInfo("Code file")
                LogInfo("---------")
                LogInfo(" - before: $codeVersionBefore")
                LogInfo(" - after : $codeVersionAfter")
              }
            }  
          #endregion functions

          #region start
            LogDate "Started at"  

            #region inputs
              $versionNumber = "${{ inputs.version-number }}"
              $development = "'${{ inputs.development-version }}'"
              $production = "'${{ inputs.production-version }}'"
              $productionRegex = "'${{ inputs.production-regex }}'"
              $gitRef = "'${{ inputs.git-ref }}'"
              $manifestFilePath = "${{ inputs.manifest-file-path }}"
              $codeFilePath = "${{ inputs.code-file-path }}"
            
              LogInfo "------"
              LogInfo "Inputs"
              LogInfo "------"
              LogInfo " - version-number      = $versionNumber" 
              LogInfo " - development-version = $developmentVersion"
              LogInfo " - production-version  = $productionVersion"
              LogInfo " - production-regex    = $productionRegex"
              LogInfo " - git-ref             = $gitRef"
              LogInfo " - manifest-file-path  = $manifestFilePath"
              LogInfo " - code-file-path      = $codeFilePath"
            #endregion inputs

            #region constants
              $dateFormat = 'yyyy-MMM-dd HH:mm:ss'
              $tags = 'refs/tags/'
              $heads = 'refs/heads/'
              $versionRegex = '([0-9\\.]+)'
              $manifestRegex = 'Version="' + $versionRegex + '" Language=' # do this all inside ""?
              $codeRegex = 'Version = "' + $versionRegex + '"' # do this all inside ""?
              $versionSpecified = ($versionNumber -ne '')
              $isBranch = $gitRef.StartsWith($heads)
              $isTag = $gitRef.StartsWith($tags)
            #endregion constants

            #region variables
              $valid = $false
              $versionToSet = '0.1'
            #endregion variables
          #endregion start

          #region process
            #region fail fast
              if ($manifestFilePathExists -eq $false) {
                  $message = "The 'manifest-file-path' MUST be specified, so no version mumber can be set"

                  throw new-object System.ArgumentException $message
              }
                  
              $missingInputs = ($versionSpecified -eq $true) `
                  -and (($developmentVersion -eq '') -or ($productionVersion -eq '') -or ($gitRef -eq ''))

              if ($missingInputs -eq $true) {
                  $message = "'version-number' was not specified, therefore
                  'development-version', 'production-version', 'production-regex' and 'git-ref'
                  are all required"
              
                  throw new-object System.ArgumentException $message
              }  
              
              if ($isTag -eq $true -and $productionRegex -eq '') {
                  $message = "When pushing a tag, 'production-regex' must be specified"

                  throw new-object System.ArgumentException $message
              }
            #endregion fail fast

            LogInfo "------"
            LogInfo "Values"
            LogInfo "------"

            if ($versionSpecified -eq $true) {
              $valid = $true
              $versionToSet = $versionNumber

              LogInfo " - type    = specified"
            }
            else {
              if ($isBranch) {
                $valid = $true
                $versionToSet = $developmentVersion
                $branch = $gitRef.Replace($heads,'')
          
                LogInfo " - branch  = $branch"
                LogInfo " - type    = development"
              }
          
              if ($isTag) {
                $valid = $true
                $tag = $gitRef.Replace($tags,'')
                $isProduction = ($tag -match $productionTag)
                LogInfo " - tag     = $tag"

                if ($isProduction -eq $true) {
                  LogInfo " - type    = production"
                  $versionToSet = $productionVersion
                }
                else {
                  LogInfo " - type    = development"
                  $versionToSet = $developmentVersion
                } 
              }
            }  

            if ($versionToSet -ne '') {
              LogInfo " - version = $versionToSet"                    

              #region manifest file
                $manifestVersionBefore = GetManifestVersion($manifestFilePath)
                $manifestReplacement = 'Version="' + $versionToSet + '" Language='

                $content = [string]::join([environment]::newline, (get-content $manifestFilePath))
                $regex = New-Object System.Text.RegularExpressions.Regex $manifestRegex
                $regex.Replace($content, $manifestReplacement) | Out-File $manifestFilePath

                $manifestVersionAfter = GetManifestVersion($manifestFilePath)
              #endregion manfest file

              #region code file
                if ($codeFilePathExists -eq $true) {
                  $codeVersionBefore = GetCodeVersion($codeFilePath)
                  $codeReplacement = 'Version = "' + $versionToSet +'"'

                  $content = [string]::join([environment]::newline, (get-content $codeFilePath))
                  $regex = New-Object System.Text.RegularExpressions.Regex $codeRegex
                  $regex.Replace($content, $codeReplacement) | Out-File $codeFilePath
                  
                  $codeVersionAfter = GetCodeVersion($codeFilePath)
                }
              #endregion
            }
          #endregion process

          #region end
            if ($valid -eq $true) {
              ShowResults $manifestVersionBefore $manifestVersionAfter $codeFilePathExists $codeVersionBefore $codeVersionAfter
            }

            LogDate "Ended at"
          #endregion end
        }
        catch [System.ArgumentException] {
          LogError $_
          $valid = $false
          Exit 1
        }
        catch [System.InvalidOperationException] {
          LogError $_
          $valid = $false
          Exit 1
        }
        catch {
          LogException $_
          LogException $_.ScriptStackTrace
          $valid = $false
          Exit 1
        }
